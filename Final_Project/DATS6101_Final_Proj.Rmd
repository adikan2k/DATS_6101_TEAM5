---
title: "Final_Project"
author: "Team 5"
date: "2024-11-21"
output:
 html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_float: yes
---

```{r include=FALSE}
library(ezids)
library(dplyr)
library(tidyverse)
library(ggplot2)
#install.packages("naniar")
library(naniar)
library(gridExtra)
```



# EDA

## Data Cleaning

### Understand the Dataset
```{r}
# Loading the dataset
top_songs <- read.csv('universal_top_spotify_songs.csv', na.strings = c("", "NA"))

# Print out the first 5 rows of the dataset
xkabledplyhead(top_songs,title="The first 5 rows of the dataset")
```


```{r include=FALSE}
str(top_songs)
```


```{r}
colnames(top_songs)
```

```{r}
summary(top_songs)
```

1. Drop columns which are not useful for modelling and have no meaning on the popularity of a song

2. The minimum value of time signature of a song is 0, which is not possible (Remove rows with time signature = 0).

3. According to the data description, NAs in `country` means Global Top 50. Therefore, we will fill NAs with 'Global'.

4. Since the percentage of observations with NAs is relatively low at 0.046% of the observations; therefore, we will drop all the other observations with NAs.


### Drop irrelevant columns

```{r}
remove_col <- c(1) # Add on columns
top_songs <- top_songs[, -remove_col]
```


### Handling Missing Values

Visualize the missing values in each column
```{r}
gg_miss_var(top_songs)
```

Calculate the counts and percentage of missing values in each columns
```{r}
# Counts the missing values in each column
colSums(is.na(top_songs))

# Calculate the percentage of missing values in each column
col_na_percentages <-round(colSums(is.na(top_songs))/dim(top_songs)[1]*100, 3)
col_na_percentages
```


```{r}
# Impute the null values in country with 'Global'
top_songs$country = ifelse(is.na(top_songs$country), 'Global', top_songs$country)

# Drop observations with missing values
df_cleaned <- na.omit(top_songs)

# Drop observations with 0 time signature
df_cleaned <- df_cleaned[df_cleaned$time_signature!=0, ]
```

```{r}
print("Dimension of Dataset before Cleaning")
print(dim(top_songs))
print("Dimension of Dataset after Cleaning")
dim(df_cleaned)
```

### Convert Variables into Correct Data Types

```{r include=FALSE}
str(df_cleaned)
```

```{r}
# Convert columns into date data type
df_cleaned$snapshot_date <- as.Date(df_cleaned$snapshot_date, format = "%Y-%m-%d")
df_cleaned$album_release_date <- as.Date(df_cleaned$album_release_date, format = "%Y-%m-%d")

# Convert columns into factor data type
df_cleaned$time_signature <-factor(df_cleaned$time_signature, level= c(1, 3, 4, 5))
df_cleaned$is_explicit <- factor(as.logical(df_cleaned$is_explicit))
df_cleaned$mode <- factor(df_cleaned$mode)

str(df_cleaned)
```


```{r}
summary(df_cleaned)
```

### Outliers Detection

```{r}
selected_columns <- c(
  "popularity", "duration_ms", "danceability", 
  "energy", "loudness", "speechiness", 
  "acousticness", "instrumentalness", "liveness",
  "valence", "tempo")

boxplots_list <- list()

# Create box plots for each selected column
for (col in selected_columns) {
  boxplot <- df_cleaned %>% 
    ggplot(aes(y = .data[[col]])) +
    geom_boxplot(fill = "lightblue") +
    labs(title = paste("Box Plot for", col), y = col) +
    theme_minimal()
  print(boxplot)
}
```

### 2. How do musical preferences (song attributes or artists) vary across countries and regions?

#### 2.1 Data Preparation for Clustering 

```{r}

spotify_df <- df_cleaned

# Summarize attributes by country
country_summary <- spotify_df %>%
  group_by(country) %>%
  summarize(
    avg_acousticness = mean(acousticness, na.rm = TRUE),
    avg_danceability = mean(danceability, na.rm = TRUE),
    avg_valence = mean(valence, na.rm = TRUE),
    avg_energy = mean(energy, na.rm = TRUE),
    avg_loudness = mean(loudness, na.rm = TRUE),
    avg_instrumentalness = mean(instrumentalness, na.rm = TRUE),
    avg_tempo = mean(tempo, na.rm = TRUE),
    avg_liveness = mean(liveness, na.rm = TRUE)
  )

country_data_scaled <- scale(country_summary %>% select(-country))

```

#### K-Means Clustering

```{r}
library(factoextra)

# Elbow method to find optimal number of clusters
fviz_nbclust(country_data_scaled, kmeans, method = "wss") +
  labs(title = "Elbow Method for Optimal Clusters")

# Set optimal number of clusters
set.seed(123)
k_optimal <- 5  # Change this to 4 if you'd like to explore fewer clusters
kmeans_result <- kmeans(country_data_scaled, centers = k_optimal)

# Add cluster labels to the original dataset
country_summary$cluster <- as.factor(kmeans_result$cluster)

```

#### PCA Plot

```{r}
library(factoextra)

# Visualize PCA with clusters
fviz_pca_ind(prcomp(country_data_scaled), 
             geom.ind = "point", 
             col.ind = country_summary$cluster, 
             palette = "jco", 
             addEllipses = TRUE, 
             legend.title = "Cluster") +
  labs(title = "PCA Plot of Clusters")
```

```{r}
# Load world map and merge with clustering results
library(rnaturalearth)
library(rnaturalearthdata)
library(ggplot2)
library(RColorBrewer)
library(countrycode)

# Create a mapping table for country codes and names
country_summary <- country_summary %>%
  mutate(
    name = countrycode(country, origin = "iso2c", destination = "country.name")
  )

world <- ne_countries(scale = "medium", returnclass = "sf")

# Merge clustering results with the world map using ISO 2
world_clusters <- world %>%
  mutate(iso_a2 = countrycode(admin, origin = "country.name", destination = "iso2c")) %>%
  left_join(country_summary, by = c("iso_a2" = "country"))

# Plot the world map with clusters
ggplot(data = world_clusters) +
  geom_sf(aes(fill = cluster)) +
  scale_fill_brewer(palette = "Spectral", na.value = "grey80") +
  labs(
    title = "Clusters of Countries by Musical Preferences",
    fill = "Cluster"
  ) +
  theme_minimal() +
  theme(
    panel.background = element_rect(fill = "lightblue"),
    plot.title = element_text(size = 16, face = "bold"),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )
```

#### Summary characteristics for clusters

```{r}
# Summarize song attributes by cluster
cluster_summary <- country_summary %>%
  group_by(cluster) %>%
  summarize(
    avg_acousticness = mean(avg_acousticness, na.rm = TRUE),
    avg_danceability = mean(avg_danceability, na.rm = TRUE),
    avg_valence = mean(avg_valence, na.rm = TRUE),
    avg_energy = mean(avg_energy, na.rm = TRUE),
    avg_loudness = mean(avg_loudness, na.rm = TRUE),
    avg_instrumentalness = mean(avg_instrumentalness, na.rm = TRUE),
    avg_tempo = mean(avg_tempo, na.rm = TRUE),
    avg_liveness = mean(avg_liveness, na.rm = TRUE)
  )
print(cluster_summary)
```

#### Visualizing Attribute Differences across clusters

```{r}
# Melt data for visualization
library(reshape2)
cluster_summary_melted <- melt(cluster_summary, id.vars = "cluster")

# Plot attributes by cluster
cluster_colors <- RColorBrewer::brewer.pal(n = 5, name = "Spectral")
ggplot(cluster_summary_melted, aes(x = cluster, y = value, fill = cluster)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~variable, scales = "free", ncol = 3) +
  scale_fill_manual(values = cluster_colors)
  labs(
    title = "Comparison of Song Attributes Across Clusters",
    x = "Cluster",
    y = "Average Value"
  ) +
  theme_minimal()
```
  
#### Top Artists in Each cluster

```{r}

```


